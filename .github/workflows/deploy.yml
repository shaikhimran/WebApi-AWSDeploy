name: Build and Deploy to AWS EC2

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  DOTNET_VERSION: "8.0.x"
  AWS_REGION: "us-east-1"
  DOCKER_IMAGE_NAME: webapi-awsdeploy

jobs:
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: ${{ env.DOCKER_IMAGE_NAME }}:latest,${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker image
        run: |
          docker save ${{ env.DOCKER_IMAGE_NAME }}:latest | gzip > docker-image.tar.gz

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar.gz
          retention-days: 1

  build:
    name: Build Application (Fallback)
    runs-on: ubuntu-latest
    if: false # Disabled - using Docker deployment

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore

      - name: Build application
        run: dotnet build --configuration Release --no-restore

      - name: Publish application
        run: dotnet publish --configuration Release --output ./publish --no-build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: published-app
          path: ./publish
          retention-days: 1

  deploy-docker:
    name: Deploy Docker to AWS EC2
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Copy files to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2_key.pem
          chmod 600 ec2_key.pem
          scp -i ec2_key.pem -o StrictHostKeyChecking=no docker-image.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
          scp -i ec2_key.pem -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/ || true

      - name: Deploy Docker container on EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          DOCKER_IMAGE_NAME: ${{ env.DOCKER_IMAGE_NAME }}
        run: |
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e
            
            # Load Docker image
            echo "Loading Docker image..."
            docker load < /tmp/docker-image.tar.gz
            
            # Stop and remove old container if exists
            docker stop webapi-container || true
            docker rm webapi-container || true
            
            # Remove old image if exists (optional, to save space)
            docker rmi $DOCKER_IMAGE_NAME:latest || true
            
            # Tag the loaded image
            docker tag $DOCKER_IMAGE_NAME:latest $DOCKER_IMAGE_NAME:latest || true
            
            # Run new container
            echo "Starting new container..."
            docker run -d \
              --name webapi-container \
              -p 8080:8080 \
              --restart unless-stopped \
              -e ASPNETCORE_ENVIRONMENT=Production \
              -e ASPNETCORE_URLS=http://+:8080 \
              -e ConnectionStrings__DefaultConnection="${{ secrets.POSTGRES_CONNECTION_STRING }}" \
              $DOCKER_IMAGE_NAME:latest
            
            # Wait for container to start
            sleep 5
            
            # Check container status
            docker ps | grep webapi-container || (echo "Container failed to start" && docker logs webapi-container && exit 1)
            
            # Show container logs
            echo "Container logs:"
            docker logs webapi-container --tail 50
            
            # Cleanup
            rm -f /tmp/docker-image.tar.gz
            docker system prune -f || true
          ENDSSH

      - name: Verify deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          echo "Waiting for application to be ready..."
          sleep 10
          for i in {1..5}; do
            if curl -f http://${{ secrets.EC2_HOST }}:8080/api/Products; then
              echo "Application is ready!"
              exit 0
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          echo "Application may still be starting or there may be an issue..."

      - name: Cleanup
        if: always()
        run: |
          rm -f ec2_key.pem docker-image.tar.gz

  deploy:
    name: Deploy to AWS EC2 (Fallback - Non-Docker)
    needs: build
    runs-on: ubuntu-latest
    if: false # Disabled - using Docker deployment

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: published-app
          path: ./publish

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create deployment package
        run: |
          tar -czf deploy.tar.gz -C ./publish .

      - name: Copy files to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2_key.pem
          chmod 600 ec2_key.pem
          scp -i ec2_key.pem -o StrictHostKeyChecking=no deploy.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
          scp -i ec2_key.pem -o StrictHostKeyChecking=no appsettings.Production.json ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/ || true

      - name: Deploy on EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          APP_NAME: WebApi-AWSDeploy
          APP_PORT: 8080
        run: |
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e
            
            # Create application directory
            sudo mkdir -p /opt/$APP_NAME
            sudo chown $USER:$USER /opt/$APP_NAME
            
            # Extract deployment package
            cd /opt/$APP_NAME
            tar -xzf /tmp/deploy.tar.gz
            
            # Copy production appsettings if provided
            if [ -f /tmp/appsettings.Production.json ]; then
              cp /tmp/appsettings.Production.json ./appsettings.Production.json
            fi
            
            # Create systemd service file
            sudo tee /etc/systemd/system/$APP_NAME.service > /dev/null <<EOF
            [Unit]
            Description=$APP_NAME
            After=network.target
            
            [Service]
            Type=notify
            ExecStart=/usr/bin/dotnet /opt/$APP_NAME/WebApi-AWSDeploy.dll
            Restart=always
            RestartSec=10
            KillSignal=SIGINT
            SyslogIdentifier=$APP_NAME
            User=$USER
            Environment=ASPNETCORE_ENVIRONMENT=Production
            Environment=ASPNETCORE_URLS=http://localhost:$APP_PORT
            
            [Install]
            WantedBy=multi-user.target
            EOF
            
            # Reload systemd and restart service
            sudo systemctl daemon-reload
            sudo systemctl enable $APP_NAME
            sudo systemctl restart $APP_NAME
            
            # Wait for service to start
            sleep 5
            
            # Check service status
            sudo systemctl status $APP_NAME --no-pager || true
            
            # Cleanup
            rm -f /tmp/deploy.tar.gz /tmp/appsettings.Production.json
          ENDSSH

      - name: Verify deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          echo "Waiting for application to be ready..."
          sleep 10
          curl -f http://${{ secrets.EC2_HOST }}:8080/api/Products || echo "Application may still be starting..."

      - name: Cleanup
        if: always()
        run: |
          rm -f ec2_key.pem deploy.tar.gz

  docker-registry-deploy:
    name: Deploy via Docker Registry (Optional)
    needs: build-docker
    runs-on: ubuntu-latest
    if: false # Set to true and configure registry secrets to use registry-based deployment

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        # FIX: Using the string-comparison syntax that the parser accepts for secrets.
        if: ${{ secrets.DOCKER_USERNAME != '' && secrets.DOCKER_PASSWORD != '' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login to AWS ECR
        # FIX: Using the string-comparison syntax that the parser accepts for secrets.
        if: ${{ secrets.AWS_ECR_REGISTRY != '' }}
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.AWS_ECR_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
            ${{ secrets.AWS_ECR_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy Docker container to EC2 from Registry
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          DOCKER_REGISTRY: ${{ secrets.DOCKER_USERNAME != '' && format('{0}/{1}', secrets.DOCKER_USERNAME, env.DOCKER_IMAGE_NAME) || format('{0}/{1}', secrets.AWS_ECR_REGISTRY, env.DOCKER_IMAGE_NAME) }}
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2_key.pem
          chmod 600 ec2_key.pem
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            # Login to Docker registry if needed
            if [ -n "${{ secrets.DOCKER_USERNAME }}" ]; then
              echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            fi
            
            # Pull latest image
            docker pull $DOCKER_REGISTRY:latest
            
            # Stop and remove old container
            docker stop webapi-container || true
            docker rm webapi-container || true
            
            # Run new container
            docker run -d \
              --name webapi-container \
              -p 8080:8080 \
              --restart unless-stopped \
              -e ASPNETCORE_ENVIRONMENT=Production \
              -e ASPNETCORE_URLS=http://+:8080 \
              -e ConnectionStrings__DefaultConnection="${{ secrets.POSTGRES_CONNECTION_STRING }}" \
              $DOCKER_REGISTRY:latest
            
            # Cleanup old images
            docker image prune -f
          ENDSSH
          rm -f ec2_key.pem
